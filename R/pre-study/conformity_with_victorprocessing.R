####################
# This script aims at ensuring the conformity of the R code with the bash one.
#
# Descostes - July 2024 - R-4.4.1
####################



library("GenomeInfoDb")
library("GenomicRanges")

source("commons.R")


##################
# PARAMETERS
##################

## Files used for R and bash
maptrackpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/k50.Unique.Mappability.bed" # nolint
exptabpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/exptab.csv"
nbcpu <- 6
database_name <- "org.Hs.eg.db"

## Files obtained with BashAndR/pre-study/preprocessing.sh
protcodbedshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/MANE_Select.protein_coding.bed" # nolint
lncrnabedshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/Ensembl_canonical_TSL123.lncRNA.bed" # nolint
protcodbednoblackwindshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/makewindow/v43.MANE_protein.window200.bed" # nolint
lncrnanednoblackwindshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed" # nolint
blacklistshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/hg38-blacklist.v2.bed" # nolint
protcodnoblackfromshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/tmp2.bed" # nolint
lncrnanoblackfromshpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/tmp4.bed" # nolint
bigtsvpath <- "/g/romebioinfo/Projects/tepr/downloads/annotations/dTAG_Cugusi_stranded_20230810.tsv" # nolint

## R objects generated by R/pre-study/preprocessing.R
robjoutputfold <- "/g/romebioinfo/Projects/tepr/robjsave"
robjlist <- list(protcodbed = file.path(robjoutputfold, "protcodbed.rds"),
    protcodgr = file.path(robjoutputfold, "protcodgr.rds"),
    lncrnabed = file.path(robjoutputfold, "lncrnabed.rds"),
    lncrnagr = file.path(robjoutputfold, "lncrnagr.rds"))

## R objects generated by BashAndR/pre-study/test-preprocessing.R
robjlisttestpre <- list(joined_df = file.path(robjoutputfold, "joined_df.rds"),
    joined_df_lncrna = file.path(robjoutputfold, "joined_df_lncrna.rds"),
    bound_df = file.path(robjoutputfold, "bound_df.rds")) ## final df of scores

## other params
windsize <- 200


##################
#FUNCTIONS
##################

.returnbedstr <- function(bedtab, includeposition, nbcol) {
            bedstr <- paste(bedtab[, 1],
            if (includeposition) bedtab[, 2],
            if (includeposition) bedtab[, 3],
            bedtab[, 4],
            if (nbcol != 4) bedtab[, 5],
            if (nbcol == 6) bedtab[, 6], sep = "-")
            return(bedstr)
}

verifybed <- function(bed1, bed2, nbcol = 6, includeposition = TRUE) {

    if (!isTRUE(all.equal(nrow(bed1), nrow(bed2))))
        stop("bed1 and bed2 have different nb of rows")

    message("Building strings for comparison in verifybed")
    bedstr1 <- .returnbedstr(bed1, includeposition, nbcol)
    bedstr2 <- .returnbedstr(bed2, includeposition, nbcol)

    idx <- match(bedstr1, bedstr2)
    idxna <- which(is.na(idx))
    lna <- length(idxna)
    if (!isTRUE(all.equal(lna, 0)))
        stop("str1 and str2 do not have the same elements")
    bed2 <- bed2[idx, ]
    idxcheckvec <- c(1, if (includeposition) c(2, 3), 4, if (nbcol != 4) 5,
            if (nbcol == 6) 6)
    invisible(sapply(idxcheckvec, function(i) {
        idx <- which(bed1[, i] != bed2[, i])
        lidx <- length(idx)
        if (!isTRUE(all.equal(lidx, 0)))
            stop("Difference in col ", i)
    }))
}

removepar <- function(dfbed, substractpary = FALSE) {
    idx <- grep("PAR_", dfbed[, 4])
    if (!isTRUE(all.equal(length(idx), 0))) {
        message("\t\t Remove ", length(idx), " PAR")
        if (!substractpary)
            dfbed <- dfbed[-idx, ]
        else
            dfbed[idx, 4] <- gsub("_PAR_Y", "", dfbed[idx,4])
    }
    return(dfbed)
}

comparenoblack <- function(bashpath, dfbed) {
    ## Read file obtained with bash
    fromsh <- read.delim(bashpath, header = FALSE)

    ## Remove suffix "_PAR_Y" if present in dfbed
    dfbed <- removepar(dfbed, substractpary = TRUE)

    ## Remove last column and add transcript names and strand to match the robj
    ## format
    tmplist <- strsplit(fromsh[, 4], "_")
    tmpnames <- sapply(tmplist, "[", 1)
    tmpstrand <- sapply(tmplist, function(x) x[length(x)])
    fromsh <- data.frame(fromsh$V1, fromsh$V2, fromsh$V3, tmpnames, tmpstrand)

    verifybed(dfbed, fromsh, nbcol = 5)
    return(list(fromsh, dfbed))
}

grtobed <- function(grobj) {
    res <- data.frame(GenomeInfoDb::seqnames(grobj), BiocGenerics::start(grobj),
        BiocGenerics::end(grobj), names(grobj),
        strand = BiocGenerics::strand(grobj))
    return(res)
}


comparewind <- function(fromr_noblackshgr, fromsh_noblackwindpath, windsize) {
    ## Preparing bed df
    message("Creating ", windsize, " bins for r object")
    fromr_windgr <- makewindowsbedtools(fromr_noblackshgr, windsize)
    fromr_windbed <- grtobed(fromr_windgr)
    message("Reading ", windsize, " bins for sh object")
    fromsh_windbed <- read.delim(fromsh_noblackwindpath, header = FALSE)

    ## Format fromr_windbed according to fromsh_windbed
    framevec <- as.numeric(gsub("frame", "", sapply(strsplit(fromr_windbed[, 4], "_"), "[", 2))) # nolint
    framevec[which(is.na(framevec))] <- 0
    framevec <- framevec + 1
    transvec <- sapply(strsplit(fromr_windbed[, 4], "_"), "[", 1)
    symbolvec <- S4Vectors::elementMetadata(fromr_windgr)[["symbol"]]
    strandvec <- fromr_windbed[, 5]
    fromr_windbed <- data.frame(V1 = fromr_windbed[, 1],
        V2 = fromr_windbed[, 2], V3 = fromr_windbed[, 3],
        V4 = paste(transvec, symbolvec, strandvec, framevec, sep = "_"))

    ## Remove suffix "_PAR_Y" if present in bed
    message("Removing suffixes from bed data.frame")
    fromr_windbed <- removepar(fromr_windbed)
    fromsh_windbed <- removepar(fromsh_windbed)

    ## Note: the coordinates of the bins are not exactly the same between the
    ## R function "tile" and the bedtools function "makewindow". Therefore,
    ## verifybed(fromr_windbed, fromsh_windbed) returns an error.
    ## However, when the start and end column are left aside when comparing the
    ## two data.frame, it gives an equality. This means that each method gives
    ## the same number of bins but with slightly different coordinates.
    verifybed(fromr_windbed, fromsh_windbed, includeposition = FALSE, nbcol = 4)
    return(fromr_windgr)
}


comparedf <- function(rdf, shdf) {

    ## Removing PAR genes
    rdf <- rdf[-which(rdf$gene == "PAR"), ]
    message("rdf has ", nrow(rdf), " and shdf has ", nrow(shdf))
    if (!isTRUE(all.equal(nrow(rdf), nrow(shdf))))
        stop("rdf and shdf have different number of rows")

    ## Checking id matching
    idx <- match(rdf$id, shdf$id)
    idxna <- which(is.na(idx))
    if (!isTRUE(all.equal(length(idxna), 0)))
        stop("id column does not correspond between df")
    shdf <- shdf[idx, ]

    ## Modifying shdf biotype for uppercase difference
    shdf$biotype <- gsub("lncRNA", "lncrna", shdf$biotype)
    shdf$biotype <- gsub("protein-coding", "protein_coding", shdf$biotype)

    testrdf <- rdf[, c("biotype", "chr", "transcript", "gene",
        "strand", "window", "id")]
    testshdf <- shdf[, c("biotype", "chr", "transcript", "gene",
        "strand", "window", "id")]

    ## Correct column types
    testrdf$chr <- as.character(testrdf$chr)
    testrdf$strand <- as.character(testrdf$strand)
    testrdf$window <- as.integer(testrdf$window)
    rownames(testrdf) <- rownames(testshdf) <- NULL

    if (!isTRUE(all.equal(testrdf, testshdf)))
        stop("The final df are different")
}



##################
# MAIN
##################

message("If no error messages appear, this means conformity.")

## Loading objects
objlist <- mapply(function(obj, nameobj) {
    message("Loading ", nameobj)
    res <- readRDS(obj)
    return(res)
}, robjlist, names(robjlist), SIMPLIFY = FALSE, USE.NAMES = TRUE)

## Compare the bed files before removing black lists
protcodbedsh <- read.delim(protcodbedshpath, header = FALSE)
lncrnabedsh <- read.delim(lncrnabedshpath, header = FALSE)
verifybed(objlist[["protcodbed"]], protcodbedsh)
verifybed(objlist[["lncrnabed"]], lncrnabedsh)

## Exclude black list with the file that was used in bash
## NOTE: In the current code (preprocessing) the black list is retrieved from
## a database.
blacklistsh <- read.delim(blacklistshpath, header = FALSE)
blacklistshgr <- bedtogr(blacklistsh, strand = FALSE, symbol = FALSE)
protcodnoblackshgr <- excludeorkeepgrlist(objlist[["protcodgr"]], blacklistshgr)
lncrnanoblackshgr <- excludeorkeepgrlist(objlist[["lncrnagr"]], blacklistshgr)
protcodnoblacksh <- grtobed(protcodnoblackshgr)
lncrnanoblacksh <- grtobed(lncrnanoblackshgr)

## Compare coord with black list removed to the files obtained with bash
res1 <- comparenoblack(protcodnoblackfromshpath, protcodnoblacksh)
res2 <- comparenoblack(lncrnanoblackfromshpath, lncrnanoblacksh)

## Compare windows coordinates with bash files
protcodwindows <- comparewind(protcodnoblackshgr, protcodbednoblackwindshpath,
    windsize)
lncrnawindows <- comparewind(lncrnanoblackshgr, lncrnanednoblackwindshpath,
    windsize)

## Build the data.frame with all the info starting from
## protcodnoblackshgr/lncrnanoblackshgr, removing the low mappability track,
## then calling buildscoreforintervals. It has to be compared to the bigTSV in
## the bash script
maptrack <- read.delim(maptrackpath, header = FALSE)
maptrackgr <- bedtogr(maptrack)
protcodnoblacknomapgr <- excludeorkeepgrlist(protcodnoblackshgr, maptrackgr,
    removefrom = FALSE)
lncrnanoblacknomapgr <- excludeorkeepgrlist(lncrnanoblackshgr, maptrackgr,
    removefrom = FALSE)

## Make windows of windsize for each annotation
protcodwindows <- makewindowsbedtools(protcodnoblacknomapgr, windsize)
lncrnawindows <- makewindowsbedtools(lncrnanoblacknomapgr, windsize)

## Retrieving values from bigwig files
exptab <- read.csv(exptabpath, header = TRUE)
message("Retrieve values for protcoddf")
protcoddf <- buildscoreforintervals(protcodwindows, exptab, "protein_coding",
    nbcpu, database_name)
message("Saving object for protcoddf")
protcoddfconformity <- protcoddf
saveRDS(protcoddfconformity,
    file = file.path(robjoutputfold, "protcoddf_fromconformity.rds"))
message("Retrieve values for lncrna")
lncrnadf <- buildscoreforintervals(lncrnawindows, exptab, "lncrna", nbcpu,
    database_name)
message("Saving object for lncrna")
lncrnadfconformity <- lncrnadf
saveRDS(lncrnadfconformity,
    file = file.path(robjoutputfold, "lncrnadf_fromconformity.rds"))
message("Merging tables")
alldf <- rbind(protcoddf, lncrnadf)
message("Saving object for merged tables")
alldfconformity <- alldf
saveRDS(alldfconformity,
    file = file.path(robjoutputfold, "alldf_fromconformity.rds"))


## Reading the table obtained with the bash and R code
rdf <- alldf
shdf <- read.delim(bigtsvpath, header = FALSE)
colnames(bashalldf) <- c("biotype", "chr", "start", "end", "transcript", "gene",
    "strand", "window", "id", "name1", "score1", "name2", "score2", "name3",
    "score3", "name4", "score4", "name5", "score5", "name6", "score6", "name7",
    "score7", "name8", "score8")

comparedf(rdf, shdf)
